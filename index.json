[{"uri":"/%E5%9F%BA%E7%A1%80/","title":"基础","tags":[],"description":"","content":"基础 VerilogHDL 是一种硬件描述语言，利用它我们可以描述数字电路。在本阶段，我们会一边学习数字逻辑电路，一边尝试用 Verilog 来实现。\n本阶段所参考的书籍为：Fundamentals of Digital Logic with Verilog Design by Stephen Brown, Zvonko Vranesic\n事不宜迟，开始我们的学习吧。\n"},{"uri":"/%E5%9F%BA%E7%A1%80/1-verilog-basics/","title":"简介","tags":[],"description":"","content":" Verilog 是一种硬件描述语言，可以用来描述数字电路的行为。比如下面这个 Flip-Flop，在时钟的上升沿处，其输出 Q 会等于输入 D。用 Verilog 描述为：\nalways@(posedge clock) Q\u0026lt;=D; "},{"uri":"/%E5%9F%BA%E7%A1%80/1-introduction/","title":"Introduction","tags":[],"description":"","content":"本章会介绍：\n数字硬件的组成 数字电路的设计流程 二进制数字 信息的数字化表示 数字电路的设计流程 D P e r f o M R i t e F e n I D o e i q e n e t t n u i S s y s i i s t i i Y p Y s r p i m g e e T s e h e e a u n s e p s e d c l l i s e d i a c m t c p f d t o p i i p r i e i r l n f r o c s o r e g i o d a i n e m c d u t g c e a u c i n t n t c t o ? t i t i a o n t n s N i ? o o n N o R M e a M d k i e e n s o i c r g o n r e r r e r c o t r i s o ? n s 信息的数字化表示 在数字电路中，通过电平高低来表示 0 和 1，一般 0V 表示 0，1V 表示 1. 下面来看看如何用 0 和 1 表示数字、字母和其他信息。\n二进制数字 在十进制中，每一位数字都表示十的几次方，比如 8547 表示 $8\\times 10^3+5\\times 10^2+4\\times 10^1+7\\times 10^0$，对于任意的十进制数，比如：\n$$ D = d_{n-1}d_{n-2}\\cdots d_1d_0 $$\n都可以表示为：\n$$ V(D)=d_{n-1}\\times 10^{n-1}+d_{n-2}\\times 10^{n-2}+\\cdots d_1\\times 10^1+d_0 \\times 10^0 $$\n因此，十进制是以 10 为底数的数字系统。\n而在数字电路中，由于只能使用 0 和 1，因此必须采用二进制。二进制中的每一位称为 比特（bit），任意二进制数\n$$ B=b_{n-1}b_{n-2}\\cdots b_1b_0 $$\n都可以写成：\n$$ \\begin{align} V(B)\u0026amp;=b_{n-1}\\times 2^{n-1}+b_{n-2}\\times 2^{n-2}+\\cdots b_1\\times 2^1+b_0 \\times 2^0\\ \u0026amp;=\\sum_{i=0}^{n-1} b_i\\times 2^i \\end{align} $$\n比如：$(1101)2=1\\times 2^3 + 1\\times 2^2 + 0\\times 2^1 + 1\\times 2^0=(13){10}$，这里括号的下标表示这是几进制数。\nn bits 的二进制表示 $0$ 到 $2^n-1$ 的数字。\n十进制与二进制的转换 二进制转十进制只需要将其每一位展开为 $b_{n}\\times 2^{n}$（n从0开始）即可（见上面的例子）。十进制转二进制则相反，需要除以 2，考虑一个二进制数：\n$$ \\begin{align} V(B)\u0026amp;=b_{n-1}\\times 2^{n-1}+b_{n-2}\\times 2^{n-2}+\\cdots b_1\\times 2^1+b_0\\ V(B)/2\u0026amp;=b_{n-1}\\times 2^{n-2}+b_{n-2}\\times 2^{n-3}+\\cdots b_1 \u0026amp;\\cdots b_0 \\end{align} $$\n其最低位（Least-Significant Bit, LSB）只可能是 0 或 1，除以 2 后恰好是余数。对商继续除以2，就能得到二进制的每一位数。注意最后得到的数才是最高位（Most-Significant Bit, MSB）。\n示例：\n$$ \\begin{align} (857)_{10}\u0026amp;\\rightarrow (?)_2 \u0026amp;{\\rm Remainder} \u0026amp;\\ 857 \\div 2 \u0026amp;= 428 \u0026amp;1 \u0026amp;;{\\rm LSB}\\ 428 \\div 2 \u0026amp;= 214 \u0026amp;0 \u0026amp;\\ 214 \\div 2 \u0026amp;= 107 \u0026amp;0 \u0026amp;\\ 107 \\div 2 \u0026amp;= 53 \u0026amp;1 \u0026amp;\\ 53 \\div 2 \u0026amp;= 26 \u0026amp;1 \u0026amp;\\ 26 \\div 2 \u0026amp;= 13 \u0026amp;0 \u0026amp;\\ 13 \\div 2 \u0026amp;= 6 \u0026amp;1 \u0026amp;\\ 6 \\div 2 \u0026amp;= 3 \u0026amp;0 \u0026amp;\\ 3 \\div 2 \u0026amp;= 1 \u0026amp;1 \u0026amp;\\ 1 \\div 2 \u0026amp;= 0 \u0026amp;1 \u0026amp;;{\\rm MSB} \\end{align} $$\n$$ (857)_{10} = (1101011001)_2 $$\nASCII 字码 ASCII 使用 7 bits 来表示 128 个字符，但在计算机中一个字节一般是 8 bits，多出来的一位可以设置成 0，或用于校验（如对其余 7 位进行奇偶校验）。\n数字与模拟信信号 二进制数也可以表示模拟信号，通过数模转换电路（DAC），可以将数字转换为相应的电平。反之，通过模数转换电路（ADC），可以将模拟信号转为二进制数。\n"},{"uri":"/%E5%AE%9E%E9%AA%8C/","title":"实验","tags":[],"description":"","content":"章节 1 基础 了解该 Hugo 主题的特点以及背后的核心概念。\n"},{"uri":"/%E5%9F%BA%E7%A1%80/2-introduction-to-logic-circuits/","title":"Introduction to Logic Circuits","tags":[],"description":"","content":"本章会介绍：\n逻辑表达式和电路 布尔运算 逻辑门和简单电路的综合 CAD 和 VerilogHDL 逻辑表达式的化简与卡诺图（Karnaugh maps) 逻辑表达式 考虑一个简单的开关电路\nx S L S 表示这是一个开关，x是外部的输入信号，L表示灯。当 x=0 时，L=0；x=1时，L=1. 所以我们可以写成：\n$$ L(x)=x $$\nx 1 S x S 2 L 只有当 $x_1,x_2$ 同时为 1 时，L 才等于 1. 上面的电路则可以写成：\n$$ L(x_1,x_2)=x_1\\cdot x_2 $$\n符号 $\\cdot$ 称为 与（AND）。\nx S S x 1 2 L 当 $x_1$ 或 $x_2$ 为 1 时，L 为 1. 上面的电路可以写成：\n$$ L(x_1,x_2)=x_1+x_2 $$\n符号 $+$ 称为 或（OR）。\nx S L 当 x=0 时，L 为 1. 上面的电路可以写成：\n$$ L(x)=\\overline{x} $$\n上划线表示 非（NOT），有一些其他表示方法，比如：\n$$ \\overline{x}=x\u0026rsquo;=!x=\\sim x={\\rm NOT}; x $$\n真值表 我们介绍了基本的逻辑表达式，并给出了它们的电路定义，下面我们将给出了它们的真值表：\n$x_1,x_2$ $x_1\\cdot x_2$ $x_1+x_2$ 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 1 真值表的最左边给出所有的输入组合，而右边则给出逻辑表达式的输出。真值表可以直观地展示出逻辑表达式。真值表会随着输入指数增长，比如当输入有 3 个，则真值表有 8 行。\n$x_1,x_2,x_3$ $x_1\\cdot x_2 \\cdot x_3$ $x_1+x_2+x_3$ 0 0 0 0 0 0 0 1 0 1 0 1 0 0 1 0 1 1 0 1 1 0 0 0 1 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 与和或都可以接受多个输入，与只有在输入都为 1 时才为 1，而或在输入中有一个为 1 时就为 1.\n逻辑门 逻辑表达式在电路中可以通过晶体管/MOS管来实现，这在电路中可以用逻辑门来表示：\n通过组合逻辑门可以得到逻辑电路。\n逻辑电路的分析 例一 对于给定的逻辑电路，我们可以想象给定输入后得到什么输出，比如下面这个电路：$f=\\overline{x}_1+x_1\\cdot x_2$\n其真值表为：\n$x_1, x_2$ $A,B$ $f(x_1,x_2)$ 0 0 1 0 1 0 1 1 0 1 1 0 0 0 0 1 1 0 1 1 其时序图为：\n时序图可以用于在实际电路中，通过逻辑分析仪，来观察其实际工作情况。\n上面的逻辑表达式实际上等价于 $g=\\overline{x}_1+x_2$，它们有相同的真值表。\n例二 考虑下面的逻辑电路：\n$x,y$ L 0 0 0 0 1 1 1 0 1 1 1 0 只有当 x,y 不相同时，输出才为 1。我们把这个称为 异或（XOR），记为 $x \\oplus y$，用下面的逻辑门来表示：\n对异或门取反可以得到 同或（NAND），记为 $x \\odot y$，用下面的逻辑门来表示：\n例三 在上一节我们介绍了二进制数，考虑两个一位的二进制数相加，则可能有四种结果；\n$$ \\begin{array}{r} a\\ +b\\ \\hline s_1s_0 \\end{array} $$\n$a,b$ $s_1s_0$ 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 注意到 $s_0=a\\oplus b$，$s_1=a\\odot b$，所以可以画出如下逻辑电路：\n这个电路称为 半加器。\n布尔代数 George Boole 在 1849 年发表了用代数描述逻辑推理的方法，被后人称为 Boolean Algebra.\n公理 假设有如下公理：\n$0\\cdot 0=0$ $1+1=1$ $1\\cdot 1=1$ $0+0=0$ $0\\cdot 1=1\\cdot 0=0$ $1+0=0+1=1$ If $x=0$, then $\\overline{x}=1$ If $x=1$, then $\\overline{x}=0$ 定理 单变量定理 $x\\cdot 0=0$ $x+1=1$ $x\\cdot 1=0$ $x+0=x$ $x\\cdot x=x$ $x+x=x$ $x\\cdot\\overline{x}=0$ $x+\\overline{x}=1$ $\\overline{\\overline{x}}=x$ 以上定理很容易证明，只需要代入 0 或 1 即可。\n对偶 某个逻辑表达式的 对偶式 可以通过将 与/或 互换，0/1 互换来得到。观察上面的公理和定理，可以发现一些式子是对偶的。比如：\n$$ x+0=x \\leftrightarrow x\\cdot 1=x $$\n如果一个逻辑表达式是正确的，其对偶式也是正确的，它们的结果是一样的。因此，一般有两种方法来表示同一个逻辑表达式，通常其中一种会更简单。\n多变量定理 交换率（Commutative）\n$x\\cdot y = y\\cdot x$ $x+y=y+x$ 结合率（Associative）\n$x\\cdot(y\\cdot z)=(x\\cdot y)\\cdot z$ $x+(y+z)=(x+y)+z$ 分配律（Distributive）\n$x\\cdot(y+z)=x\\cdot y+x\\cdot z$ $x+y\\cdot z=(x+y)\\cdot(x+z)$ 吸收率（Absorption）\n$x+x\\cdot y=x$ $x\\cdot(x+y)=x$ $x\\cdot y+x\\cdot\\overline{y}=x$ $(x+y)\\cdot(x+\\overline{y})=x$ 德·摩根定律（DeMorgan\u0026rsquo;s theorem）\n$\\overline{x\\cdot y}=\\overline{x}+\\overline{y}$ $\\overline{x+y}=\\overline{x}\\cdot\\overline{y}$ $x+\\overline{x}\\cdot y=x+y$ $x\\cdot(\\overline{x}+y)=x\\cdot y$ 共识定理（Consensus）\n$x\\cdot y+y\\cdot z+\\overline{x}\\cdot z=x\\cdot y+\\overline{x}\\cdot z$ $(x+y)\\cdot(y+z)\\cdot(\\overline{x}+z)=(x+y)\\cdot(\\overline{x}+z)$ 例子 证明以下逻辑表达式：\n$$ (x_1+x_2)\\cdot(\\overline{x}+\\overline{x}_2)=x_1\\cdot\\overline{x}_2+\\overline{x}_1\\cdot x_2 $$\n展开等式左边：\n$$ \\begin{align} {\\rm LHS} \u0026amp;= (x_1+x_2)\\cdot\\overline{x}_1+(x_1+x_2)\\cdot\\overline{x}_2\\ \u0026amp;=x_1\\cdot\\overline{x}_1+x_2\\cdot\\overline{x}_1+x_1\\cdot\\overline{x}_2+x_2\\cdot\\overline{x}_2\\ \u0026amp;=0+x_2\\cdot\\overline{x}_1+x_1\\cdot\\overline{x}_2+0\\ \u0026amp;=x_2\\cdot\\overline{x}_1+x_1\\cdot\\overline{x}_2 \\end{align} $$\n韦恩图 韦恩图也可以用于证明逻辑表达式的正确性。这里就不花了，有兴趣的话可以试着证明一下共识定理。\n用与/或/非门综合 有了以上知识，我们可以尝试用与/或/非门得到所希望的逻辑功能。考虑下面的真值表：\n$x_1,x_2$ $f(x_1,x_2)$ 0 0 1 0 1 1 1 0 0 1 1 1 要写出逻辑表达式，我们可以将 $f=1$ 的行相加：\n$$ f(x_1,x_2)=x_1x_2+\\overline{x}_1x_2+\\overline{x}_1\\overline{x}_2 $$\n注：以后我们写逻辑表达式时将省略 $\\cdot$ 号。\n但这样得到的式子并不是最简的。我们可以采取下面的化简方式：\n$$ \\begin{align} f(x_1,x_2) \u0026amp;= x_1x_2 + \\overline{x}_1x_2+ \\overline{x}_1x_2+\\overline{x}_1\\overline{x}_2\\ \u0026amp;=(x_1+\\overline{x}_1)x_2+\\overline{x}_1(\\overline{x}_2+x_2)\\ \u0026amp;=x_2+\\overline{x}_1 \\end{align} $$\n直接用定理化简并不直观，所以后面我们会介绍另一种方法叫“卡诺图”。\n积的和、和的积 下面我们将用专业术语来描述逻辑函数综合的过程。为了方便描述，我们将“与”看作乘，“或”看作除\n最小项 如果一个函数有 $n$ 个变量，则包含这 $n$ 个变量的乘积称为 最小项（Minterm），变量可能是 $x_i$ 或 $\\overline{x}_i$。真值表中的每一行都可以用一个最小项来表示。\n行号 $x_1,x_2,x_3$ Minterm 0 0 0 0 $m_0=\\overline{x}_1 \\overline{x}_2 \\overline{x}_3$ 1 0 0 1 $m_1=\\overline{x}_1 \\overline{x}_2 x_3$ 2 0 1 0 $m_2=\\overline{x}_1 x_2 \\overline{x}_3$ 3 0 1 1 $m_3=\\overline{x}_1 x_2 x_3$ 4 1 0 0 $m_4=x_1 \\overline{x}_2 \\overline{x}_3$ 5 1 0 1 $m_5=x_1 \\overline{x}_2 x_3$ 6 1 1 0 $m_6=x_1 x_2 \\overline{x}_3$ 7 1 1 1 $m_7=x_1 x_2 x_3$ 积的和 任何逻辑表达式可以用最小项的和来表示，即 积的和（sum-of-products）。如果我们给真值表的每一行编号，并将对应的最小值记为 $m_i$，则逻辑表达式 $f$ 可以用如下形式表示：\n$$ f(x_1,x_2,x_3) = \\sum (m_i) $$\n或\n$$ f(x_1,x_2,x_3) = \\sum m(i) $$\n其中，$i$ 是真值表中，$f=1$ 的行。\n最大项 根据对偶定理，如果一个逻辑表达式 $f$ 可以用真值表中 $f=1$ 的最小项的和来表示，那么也可以用真值表中 $f=0$ 的最大项的积来表示。最大项即包含所有变量的和的项，记为 $M_i$，见下表：\n行号 $x_1,x_2,x_3$ Maxterm 0 0 0 0 $M_0=x_1+ x_2+ x_3$ 1 0 0 1 $M_1=x_1+ x_2+ \\overline{x}_3$ 2 0 1 0 $M_2=x_1+ \\overline{x}_2+ x_3$ 3 0 1 1 $M_3=x_1+ \\overline{x}_2+ \\overline{x}_3$ 4 1 0 0 $M_4=\\overline{x}_1+ x_2+ x_3$ 5 1 0 1 $M_5=\\overline{x}_1+ x_2+ \\overline{x}_3$ 6 1 1 0 $M_6=\\overline{x}_1+ \\overline{x}_2+ x_3$ 7 1 1 1 $M_7=\\overline{x}_1+ \\overline{x}_2+ \\overline{x}_3$ 注意每一行的最大项和最小项中是相反的，比如 $m_0=\\overline{x}_1 \\overline{x}_2 \\overline{x}_3$，$M_0=x_1+ x_2+ x_3$，满足 $m_0 = \\overline{M}_0$（德·摩根定律）\n和的积 对于一个逻辑表达式 $f=\\sum (m_i)$，其中 $m_i$ 为真值表中 $f=1$ 的行，则 $\\overline{f}=\\sum (m_j)$，$j$ 为真值表中 $f=0$ 的行。于是我们有：\n$$ \\overline{\\overline{f}} = \\sum (\\overline{m}_j) $$\n根据德·摩根定理，$\\overline{m_j} = M_j$，因此，我们有：\n$$ f = \\overline{\\overline{f}} = \\prod (M_j) $$\n或\n$$ f= \\prod M(j) $$\n其中，$j$ 为真值表中 $f=0$ 的行。\n用与/或/非表示积的和、和的积 （略）\n只包含 NAND 或 NOR 的逻辑电路 上面描述了如何用与/或/非门来综合逻辑表达式，实际上，只用与非 NAND ，或只用或非 NOR，也可以实现。\n与非、或非相比于与、或的最大好处是，它们的底层晶体管结构更加简单。\n下面来描述如何只用与非/或非来实现逻辑表达式。对于一个积的和\n$$ f = \\sum (m_i) $$\n根据德·摩根定理，有：\n$$ f = \\overline{\\prod (\\overline{m}_i)} $$\n那么就可以只用与非来实现。用图可能更好理解：\n同理，对于一个和的积，我们有：\n$$ \\begin{align} f \u0026amp;= \\prod (M_i)\\ \u0026amp;= \\overline{\\sum (\\overline{M}_i)} \\end{align} $$\n对于某些最小项、最大项，可能需要对变量取反，我们也可以利用 NAND/NOR 来实现 NOT\n设计示例 双输入选择器 功能：两个输入 $x_1,x_2$，开关 $s$ 控制输出 $f$ 等于哪个输入，即：\n$$ f = \\begin{cases} x_1 \u0026amp; s=0\\ x_2 \u0026amp; s=1 \\end{cases} $$\n列出真值表：\n$s,x_1,x_2$ $f$ 0 0 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 0 1 1 1 1 写出积的和：\n$$ f=\\overline{s}x_1\\overline{x}_2+\\overline{s}x_1x_2+s\\overline{x}_1x_2+sx_1x_2 $$\n利用分配律，可以写成：\n$$ \\begin{align} f\u0026amp;=\\overline{s}x_1(\\overline{x}_2+x_2)+sx_2(\\overline{x}_1+x_1)\\ \u0026amp;=\\overline{s}x_1+sx_2 \\end{align} $$\n可以推广到 $n$ 路选择器：\n$$ f = \\sum m_{si}x_i $$\n$m_{si}$ 为由选择信号组成的最小项，$x_i$ 为某组选择信号有效时的输出。\nCAD工具简介 上面所列举的逻辑电路比较简单，人手可以简化，但如果系统比较复杂，那么就必须用 CAD（Computer Aid Design），CAD 工具会完成如下几个任务：\ndesign entry logic synthesis \u0026amp; optimization simulation physical design N S o c h e N m o T D a F i e t u m s i n T i C i c c D P i n h g D t e h m g i n e c i s y i p s a S o i Y s n r c i p y n g e i g e c o g t n a n s c q o n n u t l a s u n c r h c l i i f e e e e s o m r i p n s i r d u e g t t i m r e l m u i r s u e s a e r o y l c i t n a n a t g i t t V t ? n o s i e i n o r o m n i n e l t o ? g Design Entry 设计逻辑电路的第一步是决定该电路的功能和结构，这显然是由人来设计的。然后我们需要向 EDA 工具描述这个电路，也就是 design entry.\nDesign entry 有两种方式：\nSchematic Capture：通过画电路图，如逻辑门等，以图形化的方式描述 优点：易于使用 缺点：难以描述大型电路 Hardware Description Language：通过硬件描述语言，用代码来描述 优点：可移植（不同工具都能用，无需改代码）、易读 这两种方式可以结合使用，我们可以用 HDL 描述底层逻辑，然后用 Schematic Capture 把各模块连接到一起。\n我们所使用的 HDL 是 Verilog HDL\nLogic Synthesis 综合就是由 design entry 设计出逻辑电路。一开始转换得到的逻辑电路并不是最简的，所以 CAD 会自动优化以获得更好的电路。\nFunctional Simulation 对逻辑表达式进行模拟以验证功能的正确性。这要求用户指明输入的数据。输出的结果一般是时序图，用户可以检查它是否满足需求。\nPhysical Design 从物理上设计实现综合得到的逻辑电路，确定各个功能在芯片上的位置。\nTiming Simulation 用电路实现的逻辑门会存在延迟，输入到输出存在 “propagation delay”（传播延迟）。时序仿真会考虑这些延迟。如果仿真结果不满足需求，我们需要在 physical design 时对 CAD 工具增加时序限制。如果还是不满足，则需要优化综合过程、甚至优化最开始的设计。\nCircuit Implementation 如果一切都满足要求，那么就可以在实际芯片上实现电路（芯片制造或FPGA烧录）\nVerilog 简介 Verilog 中有多种描述目标电路的方式，一种是利用电路元件（比如逻辑门）来描述，称为 structural representation，另一种则是通过逻辑表达式来描述，称为 behavioral representation\nStructural Specification of Logic Circuits Verilog 包含一组门级的语句，比如一个双输入（$x_1,x_2$）单输出（$y$）的与门：\nand(y, x1, x2) 四输入的或门：\nor(y, x1, x2, x3, x4) 完整的门级语句见下表：\n名字 描述 用法 and $f=(a\\cdot b \\cdots)$ and(f,a,b,...) nand $f=\\overline{(a\\cdot b \\cdots)}$ nand(f,a,b,...) or $f=(a+b+\\cdots)$ or(f,a,b,...) nor $f=\\overline{(a+b+\\cdots)}$ nor(f,a,b,...) xor $f=(a\\oplus b \\oplus\\cdots)$ xor(f,a,b,...) not $f=\\overline{a}$ not(f,a) buf $f=a$ buf(f,a) notif0() $f=(!e ? \\overline{a}:\u0026lsquo;bz)$ notif0(f,a,e) notif1() $f=(e ? \\overline{a}:\u0026lsquo;bz)$ notif1(f,a,e) bufif0() $f=(!e ? a:\u0026lsquo;bz)$ bufif0(f,a,e) bufif1() $f=(e ? a:\u0026lsquo;bz)$ bufif1(f,a,e) 一个逻辑电路以 module 的形式定义，先指明端口（输入、输出），然后定义内部的逻辑语句。以下面这个选择器为例：\nmodule multiplexer(x1, x2, s, f) input x1, x2, s; output f; not(k,s); and(g,k,x1); and(h,s,x2); or(f,g,h); endmodule 我们也可以用 ~x 来表示取反，因此可以不用 not：\nmodule multiplexer(x1, x2, s, f) input x1, x2, s; output f; and(g,~s,x1); and(h,s,x2); or(f,g,h); endmodule 在 Veriog 中，输入、输出等量称为信号（Signal），信号和模块的命名都必须以字母开头，可以包含字母、_、$。Verilog 是大小写敏感的。\nVerilog 的注释用 // 来表示。\nBehavioral Specification of Logic Circuits 用门级语句来描述电路太冗长了，我们可以用更简单的方式来描述，比如使用逻辑表达式\n$$ f = \\overline{s}x_1+ s x_2 $$\nmodule multiplexer(x1, x2, s, f) input x1, x2, s; output f; assign f=(~s$x1)|(s\u0026amp;x2); endmodule 在 Verilog 中，与、或分别是 \u0026amp; 和 |，assign f= 表示连续赋值（continuous assignment），即 = 右边的信号变化时，会重新计算 = 左边的信号。\n这种方式能简化代码，但有一种更高级的抽象方法，即使用 if-else 语句：\nif(s==0) f=x1; else f=x2; 这种方式更加直观地说明了电路的功能。if-else 属于 Verilog 中的流程语句（procedural statement），流程语句必须包裹在 always 块中，因此完整的模块应该是：\n// Behavioral specification module multiplexer(x1, x2, s, f) input x1, x2, s; output f; ref f; always@(x1 or x2 or s) if(s==0) f=x1; else f=x2; endmodule always 块中可以有多条语句，一个模块中也可以有多个 always 块。always 块内的语句是按顺序执行的，相比之下，always块外部的连续赋值语句是并行执行的。\nalways @ 后面括号内的是 敏感表（sensitivity list），当敏感表内的信号变化时，always 内的语句才会执行。这样做的好处是在仿真的时候，就不需要每次都执行所有语句了。\n如果在流程语句中对信号赋值，则 Verilog 要求这个信号被声明为一个变量，用 reg 来声明。reg 表示 register（寄存器），赋值结束后，在下一次 always 语句执行前，reg 会一直存储这个值。reg 可以和 output 一起使用，比如：\noutput reg f; 另外，在 Verilog 2001 标准中，信号的方向和类型可以写在括号内。另外，敏感表内也可以用 , 代替 or：\n// Behavioral specification module multiplexer(input x1, x2, s, output reg f) always@(x1, x2, s) if(s==0) f=x1; else f=x2; endmodule 还有，我们可以不用在敏感表中列出所有信号，而是用 always@(*) 或 always@* 让编译器自己找出哪些变量需要考虑。\nVerilog 的层级 对于大型的电路，可以划分为不同层级的模块，高层级的模块调用低层级的模块。比如下图包含两个底层模块，一个负责运算（将输入相加）另一个负责显示\n// An adder module module adder (a, b, s1, s0); input a, b; output s1, s0; assign s1 = a \u0026amp; b; assign s0 = a ^ b; endmodule // A module for driving a 7-segment display module display (s1, s0, a, b, c, d, e, f, g); input s1, s0; output a, b, c, d, e, f, g; assign a = ~s0; assign b = 1; assign c = ~s1; assign d = ~s0; assign e = ~s0; assign f = ~s1 \u0026amp; s0; assign g = s1 \u0026amp; s0; endmodule module adder_display (x, y, a, b, c, d, e, f, g); input x, y; output a, b, c, d, e, f, g; wire w1, w0; adder U1 (x, y, w1, w0); display U2 (w1, w0, a, b, c, d, e, f, g); endmodule 在顶层模块中 adder_display 中，w1, w0 不是输入输出，而是中间的连线，所以声明为 wire。顶层模块内部实例化了一个 adder 和 display，分别命名为 U1, U2，并按照底层模块定义时的顺序在括号中传递信号。\n"},{"uri":"/%E5%B7%A5%E5%85%B7/","title":"工具","tags":[],"description":"","content":"笔记工具 Markdeep Diagram Drafting Board\n"},{"uri":"/%E5%9F%BA%E7%A1%80/2.1-strategy-for-minimization/","title":"Strategy for Minimization","tags":[],"description":"","content":"简化逻辑表达式的策略 下面我们将介绍如何使用卡诺图（karnaugh map）来获得逻辑表达式的最简形式。\n术语 Literal: Each appearance of a variable in a product term, either uncomplemented or complemented, is called a literal.（即乘积中的变量） Implicant: A product term that indicates the input valuation(s) for which a given function is equal to 1 is called an implicant of the function.（即某个乘积为 1 时，$f=1$，则这个乘积就是 implicant） Prime Implicant: An implicant is called a prime implicant if it cannot be combined into another implicant that has fewer literals.（不能进一步化简的 implicant） Cover: A collection of implicants that account for all valuations for which a given function is equal to 1 is called a cover of that function. （能使 $f=1$ 的一组 implicants） Cost: The number of gates plus the total number of inputs to all gates in the circuit. We will assume that primary inputs, namely, the input variables, are available in both true and complemented forms at zero cost.（门+门的输入，注意正负变量一开始就有，是不算cost的） 关于 Cost，举个例子：\n$$ f=x_1\\overline{x}_2+x_3\\overline{x}_4 $$\n有 2 个 AND，1 个 OR. 三个门共有 6 个输入，所以总的 cost=9. 注意 $\\overline{x}_2,\\overline{x}_4$ 是本来就有的输入，不算 cost\n简化流程 Generate all prime implicants for the given function f. Find the set of essential prime implicants. If the set of essential prime implicants covers all valuations for which f = 1, then this set is the desired cover of f. Otherwise, determine the nonessential prime implicants that should be added to form a complete minimum-cost cover. "},{"uri":"/%E5%9F%BA%E7%A1%80/3-number-and-arithmetic/","title":"Number Representation and Arithmetic Circuits","tags":[],"description":"","content":""},{"uri":"/","title":"Learn Theme for Hugo","tags":[],"description":"","content":"Hugo learn theme Hugo-theme-learn is a theme for Hugo, a fast and modern static website engine written in Go. Where Hugo is often used for blogs, this multilingual-ready theme is fully designed for documentation.\nThis theme is a partial porting of the Learn theme of Grav, a modern flat-file CMS written in PHP.\n"},{"uri":"/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"/tags/","title":"Tags","tags":[],"description":"","content":""}]